library(zouhw2)
install.packages("zouhw2")
library(devtools)
devtools::check("zouhw2")
devtools::check("R")
install.packages("roxygen2")
library(roxygen2)
#' @param b n*1 vector of the input system Ax=b
#' @param cores Number of cores used in parallel computing of Jacobi Mathod. If cores=1,use sequential method, otherwise use parallel computing.
#' @param method Method to use. "GS"=Gauss-Seidel,"Jacobi"=Jacobi
#' @param iteration Number of iterations
#'
#' @import doParallel,foreach
#' @return xi n*1 vector, solution of the input system Ax=b
#' @export
#'
#' @examples solve_ols()
solve_ols <- function(A,b,cores,method,iteration){
n=length(b)
x0 = as.vector(rep(0,n))
L <-matrix(0,n,n)
D <-matrix(0,n,n)
U <-matrix(0,n,n)
diag(D) <- diag(A)
L[lower.tri(L)] <- A[lower.tri(A)]
U[upper.tri(L)] <- A[upper.tri(A)]
xi=x0
if (method=="GS"){
#Gauss-Seidel
for (i in 1:iteration){
xi = solve(L+D)%*%(b-U%*%xi)
}
}
if(method=="Jacobi"){
if(cores==1){
#Jacobi (sequential)
for (i in 1:iteration){
xi = solve(D)%*%(b-((L+U)%*%xi))
}
}
else{
#Jacobi (parallel)
library(doParallel)
library(foreach)
cl <- makeCluster(cores)
registerDoParallel(cl)
outlist=foreach (i=1:iteration) %dopar% {
xi = solve(D)%*%(b-(L+U)%*%xi)
}
xi=outlist[iteration]
}}
return(xi)}
solve_ols(matrix(rnorm(100),10,10),matrix(rnorm(100),10,10)%*%rep(c(0,1),10),"GS",10)
diag(rep(1, 3))
a=diag(rep(1, 3))
b=rep(1,3)
solve_ols(a,b,"GS",10)
a=matrix(rnorm(9),3,3)
v=rep(1,3)
solve_ols(a,a%*%v,"GS",10)
a
A=a
b=A%*%v
b
n=length(b)
x0 = as.vector(rep(0,n))
L <-matrix(0,n,n)
D <-matrix(0,n,n)
U <-matrix(0,n,n)
diag(D) <- diag(A)
L[lower.tri(L)] <- A[lower.tri(A)]
U[upper.tri(L)] <- A[upper.tri(A)]
xi=x0
L
U
solve(L+D)%*%(b-U%*%xi)
solve(L+D)%*%(b-U%*%xi)
xi=solve(L+D)%*%(b-U%*%xi)
xi=solve(L+D)%*%(b-U%*%xi)
xi=solve(L+D)%*%(b-U%*%xi)
xi
solve_ols(a,a%*%v,method = "GS",10)
solve_ols(a,a%*%v,method = "GS",iteration=10)
solve_ols(a,a%*%v,method = "GS",iteration=10)
solve_ols(a,a%*%v,method = "Jacobi",iteration=10)
solve_ols(a,a%*%v,cores=1,method = "Jacobi",iteration=10)
solve_ols(a,a%*%v,cores=2,method = "Jacobi",iteration=10)
#' Title
#'
#' @param xi independent variables
#' @param yi response variable
#' @param r the sampling size,default=20% of the input data
#'
#' @return b_est the estimated regression coefficients
#' @export
#'
#' @examples
algo_leverage <- function(xi,yi,r=floor(0.2*length(yi))){
n=length(yi)
hii <- diag(xi%*%(t(xi)%*%xi)%*%t(xi))
unif <- sample(n,r,replace = TRUE)
blev <- sample(n,r,replace = TRUE,prob =hii/sum(hii))
if(NCOL(xi)>1){
xunif <- xi[unif,]
xblev <- xi[blev,]
}
else{
xunif <- xi[unif]
xblev <- xi[blev]
}
yunif <- yi[unif]
yblev <- yi[blev]
b_unif= solve(t(xunif)%*%xunif)%*%t(xunif)%*%yunif
b_blev= solve(t(xblev)%*%xblev)%*%t(xblev)%*%yblev
b_est <- list(b_unif,b_blev)
return(b_est)
}
View(xi)
solve_ols(a,a%*%v,cores=2,method = "Jacobi",iteration=100)
solve_ols(a,a%*%v,method = "GS",iteration=100)
xi=x0
for (i in 1:5){
xi = solve(L+D)%*%(b-U%*%xi)
}
xi
for (i in 1:10){
xi = solve(L+D)%*%(b-U%*%xi)
}
xi
x <- matrix(rnorm(500),100,5)
y <- x%*%rep(-1,5)+rnorm(100)
View(y)
algo_leverage(x,y)
algo_leverage(x,y,10)
L
U
A
U[upper.tri(L)] <- A[upper.tri(A)]
U
#' @return xi n*1 vector, solution of the input system Ax=b
#' @export
#'
#' @examples
#' a=matrix(rnorm(9),3,3)
#' v=rep(1,3)
#' b=a%*%v
#' solve_ols(a,b,method = "GS",iteration=100)
#' solve_ols(a,b,cores=1,method = "Jacobi",iteration=100)
#' solve_ols(a,b,cores=2,method = "Jacobi",iteration=100)
solve_ols <- function(A,b,cores=1,method,iteration){
n=length(b)
x0 = as.vector(rep(0,n))
L <-matrix(0,n,n)
D <-matrix(0,n,n)
U <-matrix(0,n,n)
diag(D) <- diag(A)
L[lower.tri(L)] <- A[lower.tri(A)]
U[upper.tri(U)] <- A[upper.tri(A)]
xi=x0
if (method=="GS"){
#Gauss-Seidel
for (i in 1:iteration){
xi = (solve(L+D))%*%(b-U%*%xi)
}
}
if(method=="Jacobi"){
if(cores==1){
#Jacobi (sequential)
for (i in 1:iteration){
xi = solve(D)%*%(b-((L+U)%*%xi))
}
}
else{
#Jacobi (parallel)
library(doParallel)
library(foreach)
cl <- makeCluster(cores)
registerDoParallel(cl)
outlist=foreach (i=1:iteration) %dopar% {
xi = solve(D)%*%(b-(L+U)%*%xi)
}
xi=outlist[iteration]
}}
return(xi)}
v
solve_ols(a,b,method = "GS",iteration=100)
a
b
U[upper.tri(U)] <- A[upper.tri(A)]
U
A
U[upper.tri(U)]
L
xi
xi=x0
xi
xi = (solve(L+D))%*%(b-U%*%xi)
xi
xi = (solve(L+D))%*%(b-U%*%xi)
xi
xi = (solve(L+D))%*%(b-U%*%xi)
xi
xi = (solve(L+D))%*%(b-U%*%xi)
xi
D
#' @return xi n*1 vector, solution of the input system Ax=b
#' @export
#'
#' @examples
#' a=matrix(rnorm(9),3,3)
#' v=rep(1,3)
#' b=a%*%v
#' solve_ols(a,b,method = "GS",iteration=100)
#' solve_ols(a,b,cores=1,method = "Jacobi",iteration=100)
#' solve_ols(a,b,cores=2,method = "Jacobi",iteration=100)
solve_ols <- function(A,b,cores=1,method,iteration){
n=length(b)
x0 = as.vector(rep(0,n))
L <-matrix(0,n,n)
D <-matrix(0,n,n)
U <-matrix(0,n,n)
diag(D) <- diag(A)
L[lower.tri(L)] <- A[lower.tri(A)]
U[upper.tri(U)] <- A[upper.tri(A)]
xi=x0
if (method=="GS"){
#Gauss-Seidel
for (i in 1:iteration){
xi = (solve(L+D))%*%(b-U%*%xi)
if(norm(-solve(D)%*%(L+U))<1){break}
}
}
if(method=="Jacobi"){
if(cores==1){
#Jacobi (sequential)
for (i in 1:iteration){
xi = solve(D)%*%(b-((L+U)%*%xi))
}
}
else{
#Jacobi (parallel)
library(doParallel)
library(foreach)
cl <- makeCluster(cores)
registerDoParallel(cl)
outlist=foreach (i=1:iteration) %dopar% {
xi = solve(D)%*%(b-(L+U)%*%xi)
}
xi=outlist[iteration]
}}
return(xi)}
solve_ols(a,b,method = "GS",iteration=100)
solve_ols(a,b,method = "GS",iteration=10)
all.equal(U+L+D[[1]],A[[1]])
all.equal(U+L+D,A)
(solve(L+D))
(b-U%*%xi)
(solve(L+D))%*%(b-U%*%xi)
xi=(solve(L+D))%*%(b-U%*%xi)
solve_ols(a,b,method = "GS",iteration=10)
solve_ols(a,b,method = "GS",iteration=2)
solve_ols(a,b,method = "GS",iteration=30)
#' @param y n*1 vector;response variable
#' @param a a constant;the l-2 regularization coefficient
#' @param lambda a constant;the l-1 and l-2 regularization coefficient
#' @param betahat p*1 vector;the initial regression coefficient
#' @param maxiteration
#'
#' @return betahat the estimated regression coefficient
#' @export
#'
#' @examples
elnet_coord <- function(x,y,a,lambda,betahat,maxiteration=100){
for (i in 1:maxiteration) {
beta1 <- betahat
for (j in 1:NCOL(x)) {
r <- y-x%*%beta1+x[,j]*beta1[j]
num <- 2*(x[,j]%*%r)/n-a*lambda
denom <- 2*(sum(x[,j]^2)/n+(1-a)*lambda)
if (num==0){
beta1[j]=0
}
else{
#solve beta1[j] by equating derivatives of minimizing function to zero. There're 2 cases:
#1. beta1>0; 2. beta1<0
beta1[j]=ifelse(num>0,num/denom,(num+2*a*lambda)/denom)
}
}
if(sum(abs(beta1-betahat))<=10^(-7)){
break
}
betahat <- beta1
}
return(betahat)
}
elnet_coord(x,y,0.5,1)
#' @param y n*1 vector;response variable
#' @param a a constant;the l-2 regularization coefficient
#' @param lambda a constant;the l-1 and l-2 regularization coefficient
#' @param betahat p*1 vector;the initial regression coefficient;default is a zero vector
#' @param maxiteration
#'
#' @return betahat the estimated regression coefficient
#' @export
#'
#' @examples
elnet_coord <- function(x,y,a,lambda,betahat=rep(0,NCOL(x)),maxiteration=100){
for (i in 1:maxiteration) {
beta1 <- betahat
for (j in 1:NCOL(x)) {
r <- y-x%*%beta1+x[,j]*beta1[j]
num <- 2*(x[,j]%*%r)/n-a*lambda
denom <- 2*(sum(x[,j]^2)/n+(1-a)*lambda)
if (num==0){
beta1[j]=0
}
else{
#solve beta1[j] by equating derivatives of minimizing function to zero. There're 2 cases:
#1. beta1>0; 2. beta1<0
beta1[j]=ifelse(num>0,num/denom,(num+2*a*lambda)/denom)
}
}
if(sum(abs(beta1-betahat))<=10^(-7)){
break
}
betahat <- beta1
}
return(betahat)
}
elnet_coord(x,y,0.5,1)
library(devtools)
install_github("zouhw2")
install_github("xyzou685/STSCI6520_HW2")
